<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>3  Using the FixedPointAcceleration package · FixedPointAcceleration</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FixedPointAcceleration</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../1_FixedPoints/">1 Fixed point acceleration</a></li><li><a class="tocitem" href="../2_Algorithms/">2 Acceleration algorithms</a></li><li class="is-active"><a class="tocitem" href>3  Using the FixedPointAcceleration package</a><ul class="internal"><li><a class="tocitem" href="#.1-Basic-examples-of-using-FixedPointAcceleration"><span>3.1 Basic examples of using FixedPointAcceleration</span></a></li><li><a class="tocitem" href="#.2-Easily-changing-algorithm"><span>3.2 Easily changing algorithm</span></a></li><li><a class="tocitem" href="#.3-Graceful-error-handling"><span>3.3 Graceful error handling</span></a></li><li><a class="tocitem" href="#.4-Convergence-by-constant-increments"><span>3.4 Convergence by constant increments</span></a></li></ul></li><li><a class="tocitem" href="../4_Applications/">4 Applications</a></li><li><a class="tocitem" href="../5_TerminationConditions/">5 Termination conditions and Error handling.</a></li><li><a class="tocitem" href="../99_refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>3  Using the FixedPointAcceleration package</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>3  Using the FixedPointAcceleration package</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/FixedPointAcceleration.jl/blob/master/docs/src/3_UsingAdvice.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-the-FixedPointAcceleration-package"><a class="docs-heading-anchor" href="#Using-the-FixedPointAcceleration-package">3  Using the FixedPointAcceleration package</a><a id="Using-the-FixedPointAcceleration-package-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-FixedPointAcceleration-package" title="Permalink"></a></h1><h2 id=".1-Basic-examples-of-using-FixedPointAcceleration"><a class="docs-heading-anchor" href="#.1-Basic-examples-of-using-FixedPointAcceleration">3.1 Basic examples of using FixedPointAcceleration</a><a id=".1-Basic-examples-of-using-FixedPointAcceleration-1"></a><a class="docs-heading-anchor-permalink" href="#.1-Basic-examples-of-using-FixedPointAcceleration" title="Permalink"></a></h2><h3 id="The-Babylonian-method-for-finding-square-roots."><a class="docs-heading-anchor" href="#The-Babylonian-method-for-finding-square-roots.">The Babylonian method for finding square roots.</a><a id="The-Babylonian-method-for-finding-square-roots.-1"></a><a class="docs-heading-anchor-permalink" href="#The-Babylonian-method-for-finding-square-roots." title="Permalink"></a></h3><p>Now we will demonstrate how <strong>FixedPointAcceleration</strong> can be used for simple problems. For the simplest possible case consider we want to estimate a square root using the Babylonian method. To find the square root of a number <span>$x$</span>, given an initial guess <span>$t_0$</span> the following sequence converges to the square root:</p><div>\[t_{n+1} = \frac{1}{2} \left[ t_n + \frac{x}{t_n} \right]\]</div><p>This is a fast converging and inexpensive sequence which probably makes an acceleration algorithm overkill but for sake of exposition we can implement this in <strong>FixedPointAcceleration</strong>. In the next code block we find the square root of 100 with the simple method:</p><pre><code class="language-none">using FixedPointAcceleration
SequenceFunction(x) = 0.5 .* (x .+ 100 ./ x)
Initial_Guess = 6.0
FP_Simple   = fixed_point(SequenceFunction, Initial_Guess; Algorithm = :Simple)</code></pre><p>We can also solve for a vector of fixed points at the same time. For instance every square root from 1 to 100.</p><pre><code class="language-none">NumbersVector = collect(1:100)
SequenceFunction(x) = 0.5 .* (x .+ NumbersVector ./ x)
Initial_Guess = repeat([10],100)
FP_SEA   = fixed_point(SequenceFunction, Initial_Guess; Algorithm = :RRE)</code></pre><p>Note that in this case the RRE method is being applied elementwise.</p><h3 id="Vectorised-functions"><a class="docs-heading-anchor" href="#Vectorised-functions">Vectorised functions</a><a id="Vectorised-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorised-functions" title="Permalink"></a></h3><p>The utility of the acceleration algorithms contained in <strong>FixedPoint</strong> are more apparent when applied to vectorised functions with cross dependency. For a simple example consider the below function where each entry of the vector depends on both entries of the previous iterate.</p><pre><code class="language-none">SimpleVectorFunction(x) = [0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2]]
Initial_Guess =  [0.3,900]
FP_Simple = fixed_point(SimpleVectorFunction  , Initial_Guess; Algorithm = :Simple)
FP_Anderson = fixed_point(SimpleVectorFunction, Initial_Guess; Algorithm = :Anderson)</code></pre><p>This function takes 105 iterates to find a fixed point with the simple method but only 14 with the Anderson acceleration method.</p><h2 id=".2-Easily-changing-algorithm"><a class="docs-heading-anchor" href="#.2-Easily-changing-algorithm">3.2 Easily changing algorithm</a><a id=".2-Easily-changing-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#.2-Easily-changing-algorithm" title="Permalink"></a></h2><p>We can &quot;chain&quot; together different calls to the fixed_point function in order to switch acceleration algorithm at any point. For instance consider the following function and initial guess at a fixed point:</p><pre><code class="language-none">func(x) = [0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2]]
Initial_Guess = [1.1,2.2]</code></pre><p>Now we can initially do two simple iterates. Then do three iterates with the MPE method. Then one with the simple method and then finish with the RRE method. This can be done in the following way:</p><pre><code class="language-none">fp_chain      = fixed_point(func, Initial_Guess; Algorithm = :Simple, MaxIter = 2)
fp_chain      = fixed_point(func, fp_chain; Algorithm = :MPE, MaxIter = 3)
fp_chain      = fixed_point(func, fp_chain; Algorithm = :Simple, MaxIter = 1)
fp_chain      = fixed_point(func, fp_chain; Algorithm = :RRE, MaxIter = 100)</code></pre><p>Now as it turns out The MPE (and RRE) does simple iterates except for every iterate that is a multiple of the ExtrapolationPeriod (7 by default). And so there is no difference from the above sequence of iterates and just doing all iterates with the RRE. This can be verified with the following:</p><pre><code class="language-none">fp_nochain = fixed_point(func, Inputs; Algorithm = :RRE, MaxIter = 100)
fp_chain.Iterations_ == fp_nochain.Iterations_
all(abs.(fp_chain.Inputs_ .- fp_nochain.Inputs_) .&lt; 1e-14)</code></pre><p>This does highlight that there is no waste in changing fixed_point algorithm in this way. No iterates are reevaluated.</p><p>Changing algorithms can be useful in some cases where an error occurs. For instance consider we are trying to find the fixed point of the following function:</p><pre><code class="language-none">simple_vector_function(x) = [0.5*sqrt(x[1] + x[2]), 1.5*x[1] + 0.5*x[2]]
Inputs = [0.3,900]
fp = fixed_point(simple_vector_function, Inputs; Algorithm = :Anderson)</code></pre><p>Inspecting this fp object reveals an error after the 3rditeration because Anderson tries to use a negative value for both x entries which results in the square root of a negative number. We can switch to simple iterations to get closer to the fixed point at which point Anderson will no longer try negative numbers. This will fix this.</p><pre><code class="language-none">fp = fixed_point(simple_vector_function, fp; Algorithm = :Simple, MaxIter = 7)
fp = fixed_point(simple_vector_function, fp; Algorithm = :Anderson)</code></pre><h2 id=".3-Graceful-error-handling"><a class="docs-heading-anchor" href="#.3-Graceful-error-handling">3.3 Graceful error handling</a><a id=".3-Graceful-error-handling-1"></a><a class="docs-heading-anchor-permalink" href="#.3-Graceful-error-handling" title="Permalink"></a></h2><p>Hopefully <strong>FixedPointAcceleration</strong> is well tested enough that most kind of errors will be rare. <strong>FixedPointAcceleration</strong> also offers an option (ReplaceInvalids) to ensure that no acceleration algorithm generates guess vectors that contain NaNs, Missings or Infs. This option can be set to ReplaceVector  which will replace an extrapolated vector containingNaNs, Missings or Infs by the vector output in the previous iterate. If it is set to ReplaceElement then it will replace the individual elements that are missings, NANs or Infs by the corresponding elements in the output of the previous iterate.</p><p>Errors are likely however in cases where inputs functions have a restricted domain. For example this may include functions that require the input vector to have a particular shape (ie concavity) or functions where the input vector must be strictly positive. For a simple example consider the vectorised function we introduced in section 3.1. Now rather than</p><div>\[x^\prime[1] = \frac{\sqrt{\vert x[1] + x[2] \vert}}{2}\]</div><p>we have</p><div>\[x^\prime[1] = \frac{\sqrt{ x[1] + x[2] }}{2}\]</div><p>where the output <span>$x$</span> has a prime and the inputs has no prime symbol. <span>$x^\prime[1]$</span> here is no longer real valued if the sum of the previous iterate is negative. This is what occurs in the 5th iterate of the Anderson method applied to this problem.</p><p>The FixedPoint function handles these situations gracefully by saving all previous results as well as the proposed new vector that lead to the error. In the event of such an error the FailedEvaluation_ member of the returned FixedPointResults struct will describe the issue.</p><p>This information is useful in order to diagnose the issue. In this case we might decide to modify the function to insert the absolute value function with the reasoning that the same fixed point will likely result (which we could later verify). This also allows a user to run one method until an error occurs and then switch methods. This is demonstrated below.</p><pre><code class="language-none">SimpleVectorFunction(x) = [0.5*sqrt(x[1] + x[2]), 1.5*x[1] + 0.5*x[2]]
Initial_Guess = [0.3,900]
FPSolution = FixedPoint(SimpleVectorFunction, Initial_Guess; Algorithm = :Anderson)</code></pre><pre><code class="language-none"># We can use this information to decide to switch to the simple method.
# No error results as the simple method doesn&#39;t extrapolate.
FPSolution = FixedPoint(SimpleVectorFunction, FPSolution; Algorithm = :Simple, MaxIter = 5)
# Now we switch to the Anderson Method again. No error results because we are
# close to fixed point.
FPSolution = FixedPoint(SimpleVectorFunction, FPSolution; Algorithm = :Anderson)</code></pre><h2 id=".4-Convergence-by-constant-increments"><a class="docs-heading-anchor" href="#.4-Convergence-by-constant-increments">3.4 Convergence by constant increments</a><a id=".4-Convergence-by-constant-increments-1"></a><a class="docs-heading-anchor-permalink" href="#.4-Convergence-by-constant-increments" title="Permalink"></a></h2><p>Most of the methods included in this function will fail in finding the fixed point of a function that converges by a fixed increment. For instance we may have a function that takes <span>$x$</span> and returns <span>$x$</span> shifted 1 unit (in Euclidian norm) in a straight line towards its fixed point. A realistic example of this is the training of a perceptron classifier which is explored later in section 4.3.</p><p>This case is problematic for all methods except for the simple method. The basic problem can be illustrated simply by looking at the Newton method and the Aitken method. For the Newton method the derivative is approximated by <span>$\frac{ g(x_i) - g(x_{i-1})}{x_i-x{i-1}}$</span>. When there is convergence by constant increments then <span>$g(x_i) = g(x_{i-1}) $ and the derivative is zero which means calculating the Newton method&#39;s recommended new guess of the fixed point involves division by zero. Now considering the Aitken method the new guess is given by $x_{i+1} = x_{i} - \frac{  (x_{i+1} - x_i)^2  }{  x_{i+2} - 2x_{i+1} + x_i}$</span>. When there is convergence by constant increments then <span>$x_i - x_{i+1} = x_{i+1} - x_{i+2}$</span>  and so we have <span>$x_{i+2} - 2x_{i+1} + x_i = (x_i - x_{i+1}) - (x_{i+1} - x_{i+2}) = 0$</span>. It is against not possible to calculate the new guess.<sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup></p><p>More generally similar problems exist for the other acceleration methods. When there is convergence by constant increments then then the fixed point method receives information about what direction to go in but no information about how far to go. This is a complication that is common to all of these acceleration methods in this package. In these cases it may be possible to change the function to make it converge by varying increments while retaining the same set of fixed points. This is shown in the perceptron example in section 4.2. In other cases where it is not possible to modify the function, it is advisable to use the simple method.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a>When these complications arise the ReplaceInvalids method can be used to revert to a simple iterate or to change individual elements to the corresponding values in a simple iterate. This is as described in section 3.3.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../2_Algorithms/">« 2 Acceleration algorithms</a><a class="docs-footer-nextpage" href="../4_Applications/">4 Applications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 September 2020 20:55">Tuesday 15 September 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
